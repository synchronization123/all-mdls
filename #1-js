const _opensct_api_urls = [
    'https://demo.defectdojo.org/api/v2/engagements/?tags=sct&status=Not Started&o=-created&active=true&limit=1000',
    'https://demo.defectdojo.org/api/v2/engagements/?tags=sct&status=In Progress&o=-created&active=true&limit=1000',
    'https://demo.defectdojo.org/api/v2/engagements/?tags=sct&status=Completed&o=-created&active=true&limit=1000',
    'https://demo.defectdojo.org/api/v2/engagements/?tags=sct&status=On Hold&o=-created&active=true&limit=1000'
];
const _opensct_users_api = 'https://demo.defectdojo.org/api/v2/users/';
const _opensct_dashboard_url = 'https://demo.defectdojo.org/dashboard';
const _opensct_page_size = 20;
let _opensct_engagements = [];
let _opensct_users = [];
let _opensct_current_page = 1;
let _opensct_csrf_token = '';

async function _opensct_fetchCsrfToken() {
    try {
        const response = await fetch(_opensct_dashboard_url);
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const tokenInput = doc.querySelector('input[name="csrfmiddlewaretoken"]');
        _opensct_csrf_token = tokenInput ? tokenInput.value : '';
    } catch (error) {
        console.error('Error fetching CSRF token:', error);
    }
}

async function _opensct_fetchUsers() {
    try {
        const response = await fetch(_opensct_users_api);
        const data = await response.json();
        _opensct_users = data.results;
        const select = document.getElementById('_opensct_assigned_filter');
        _opensct_users.forEach(user => {
            const option = document.createElement('option');
            option.value = user.id;
            option.textContent = `${user.first_name} ${user.last_name}`;
            select.appendChild(option);
        });
    } catch (error) {
        console.error('Error fetching users:', error);
    }
}

async function _opensct_fetchEngagements() {
    try {
        const responses = await Promise.all(_opensct_api_urls.map(url => fetch(url)));
        const data = await Promise.all(responses.map(res => res.json()));
        _opensct_engagements = data.flatMap(d => d.results);
        await _opensct_fetchUsers();
        _opensct_renderTable();
    } catch (error) {
        console.error('Error fetching engagements:', error);
    }
}

async function _opensct_fetchJiraCounts(engagementId) {
    try {
        const response = await fetch(`https://demo.defectdojo.org/api/v2/tests/?engagement=${engagementId}&tags=mcr_jira`);
        const data = await response.json();
        const tests = data.results;
        const totalJiras = tests.length;
        const pendingJiras = tests.filter(test => !['Completed', 'Rejected'].includes(test.branch_tag)).length;
        const doableJiras = tests.filter(test => 
            ['Ready for testing', 'done', 'ready for qa'].includes(test.build_id)
        ).length;
        const nonDoableJiras = pendingJiras - doableJiras;
        return { totalJiras, pendingJiras, doableJiras, nonDoableJiras };
    } catch (error) {
        console.error('Error fetching Jira counts:', error);
        return { totalJiras: 0, pendingJiras: 0, doableJiras: 0, nonDoableJiras: 0 };
    }
}

function _opensct_formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
}

function _opensct_getUserName(userId) {
    const user = _opensct_users.find(u => u.id === userId);
    return user ? `${user.first_name} ${user.last_name}` : 'Unknown';
}

function _opensct_renderTable(filteredEngagements = _opensct_engagements) {
    const tbody = document.getElementById('_opensct_table_body');
    tbody.innerHTML = '';
    const start = (_opensct_current_page - 1) * _opensct_page_size;
    const end = start + _opensct_page_size;
    const paginatedEngagements = filteredEngagements.slice(start, end);

    paginatedEngagements.forEach(async engagement => {
        const jiraCounts = await _opensct_fetchJiraCounts(engagement.id);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${_opensct_formatDate(engagement.created)}</td>
            <td>${engagement.id}</td>
            <td>${engagement.name}</td>
            <td>${jiraCounts.totalJiras}</td>
            <td>${jiraCounts.pendingJiras}</td>
            <td>${jiraCounts.doableJiras}</td>
            <td>${jiraCounts.nonDoableJiras}</td>
            <td>
                <select onchange="_opensct_updateStatus(${engagement.id}, 'analyst', this.value)">
                    <option value="Not Started" ${engagement.status === 'Not Started' ? 'selected' : ''}>Not Started</option>
                    <option value="In Progress" ${engagement.status === 'In Progress' ? 'selected' : ''}>In Progress</option>
                    <option value="On Hold" ${engagement.status === 'On Hold' ? 'selected' : ''}>On Hold</option>
                    <option value="Completed" ${engagement.status === 'Completed' ? 'selected' : ''}>Completed</option>
                </select>
            </td>
            <td>
                <select onchange="_opensct_updateStatus(${engagement.id}, 'mentor', this.value)">
                    <option value="Not Started" ${engagement.status === 'Not Started' ? 'selected' : ''}>Not Started</option>
                    <option value="In Progress" ${engagement.status === 'In Progress' ? 'selected' : ''}>In Progress</option>
                    <option value="On Hold" ${engagement.status === 'On Hold' ? 'selected' : ''}>On Hold</option>
                    <option value="Completed" ${engagement.status === 'Completed' ? 'selected' : ''}>Completed</option>
                </select>
            </td>
            <td>
                <select onchange="_opensct_updateStatus(${engagement.id}, 'lead', this.value)">
                    <option value="Not Started" ${engagement.status === 'Not Started' ? 'selected' : ''}>Not Started</option>
                    <option value="Approved" ${engagement.status === 'Approved' ? 'selected' : ''}>Approved</option>
                    <option value="Not Approved" ${engagement.status === 'Not Approved' ? 'selected' : ''}>Not Approved</option>
                    <option value="Rejected" ${engagement.status === 'Rejected' ? 'selected' : ''}>Rejected</option>
                </select>
            </td>
            <td>${_opensct_getUserName(engagement.lead)}</td>
            <td>${engagement.version || 'N/A'}</td>
            <td>${_opensct_formatDate(engagement.target_end)}</td>
            <td class="action-buttons">
                <button class="close-btn" onclick="_opensct_closeEngagement(${engagement.id})">Close</button>
                <button class="comment-btn ${engagement.description ? 'red' : ''}" onclick="_opensct_toggleComment(${engagement.id}, this)">Comment</button>
                <div class="comment-box" id="_opensct_comment_${engagement.id}">
                    <textarea>${engagement.description || ''}</textarea>
                    <button onclick="_opensct_saveComment(${engagement.id})">Save</button>
                    <button onclick="_opensct_cancelComment(${engagement.id})">Cancel</button>
                </div>
            </td>
        `;
        tbody.appendChild(row);
    });

    _opensct_renderPagination(filteredEngagements.length);
}

function _opensct_renderPagination(totalItems) {
    const totalPages = Math.ceil(totalItems / _opensct_page_size);
    const pagination = document.getElementById('_opensct_pagination');
    pagination.innerHTML = `
        <button onclick="_opensct_changePage(${_opensct_current_page - 1})" ${ _opensct_current_page === 1 ? 'disabled' : ''}>Previous</button>
        <span>Page ${_opensct_current_page} of ${totalPages}</span>
        <button onclick="_opensct_changePage(${_opensct_current_page + 1})" ${_opensct_current_page === totalPages ? 'disabled' : ''}>Next</button>
    `;
}

function _opensct_changePage(page) {
    _opensct_current_page = page;
    _opensct_renderTable();
}

function _opensct_filterTable() {
    const searchInput = document.getElementById('_opensct_search_input').value.toLowerCase();
    const assignedFilter = document.getElementById('_opensct_assigned_filter').value;
    const etaFilter = document.getElementById('_opensct_eta_filter').value;

    const filteredEngagements = _opensct_engagements.filter(engagement => {
        const matchesSearch = engagement.name.toLowerCase().includes(searchInput);
        const matchesAssigned = !assignedFilter || engagement.lead === parseInt(assignedFilter);
        const matchesEta = !etaFilter || engagement.target_end.includes(etaFilter);
        return matchesSearch && matchesAssigned && matchesEta;
    });

    _opensct_current_page = 1;
    _opensct_renderTable(filteredEngagements);
}

async function _opensct_updateStatus(engagementId, type, value) {
    const engagement = _opensct_engagements.find(e => e.id === engagementId);
    const updatedEngagement = {
        id: engagement.id,
        name: engagement.name,
        target_start: engagement.target_start,
        target_end: engagement.target_end,
        lead: engagement.lead,
        product: engagement.product,
        status: type === 'analyst' || type === 'mentor' ? value : engagement.status,
        // Add lead status handling if needed
    };

    try {
        await fetch(`https://demo.defectdojo.org/api/v2/engagements/${engagementId}/`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': _opensct_csrf_token
            },
            body: JSON.stringify(updatedEngagement)
        });
        _opensct_fetchEngagements();
    } catch (error) {
        console.error('Error updating status:', error);
    }
}

async function _opensct_closeEngagement(engagementId) {
    if (!confirm('Are you sure you want to close this engagement?')) return;
    try {
        await fetch(`https://demo.defectdojo.org/api/v2/engagements/${engagementId}/close/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': _opensct_csrf_token
            }
        });
        _opensct_fetchEngagements();
    } catch (error) {
        console.error('Error closing engagement:', error);
    }
}

function _opensct_toggleComment(engagementId, button) {
    const commentBox = document.getElementById(`_opensct_comment_${engagementId}`);
    commentBox.style.display = commentBox.style.display === 'block' ? 'none' : 'block';
}

async function _opensct_saveComment(engagementId) {
    const commentBox = document.getElementById(`_opensct_comment_${engagementId}`);
    const textarea = commentBox.querySelector('textarea');
    const engagement = _opensct_engagements.find(e => e.id === engagementId);
    const updatedEngagement = {
        id: engagement.id,
        name: engagement.name,
        target_start: engagement.target_start,
        target_end: engagement.target_end,
        lead: engagement.lead,
        product: engagement.product,
        description: textarea.value
    };

    try {
        await fetch(`https://demo.defectdojo.org/api/v2/engagements/${engagementId}/`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': _opensct_csrf_token
            },
            body: JSON.stringify(updatedEngagement)
        });
        _opensct_fetchEngagements();
    } catch (error) {
        console.error('Error saving comment:', error);
    }
}

function _opensct_cancelComment(engagementId) {
    const commentBox = document.getElementById(`_opensct_comment_${engagementId}`);
    commentBox.style.display = 'none';
}

document.addEventListener('DOMContentLoaded', () => {
    _opensct_fetchCsrfToken().then(_opensct_fetchEngagements);

    // Tab switching logic
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tab.dataset.tab).classList.add('active');
        });
    });
});